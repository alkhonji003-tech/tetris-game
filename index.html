<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Luxury Tetris</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #0d0d0d;
    overflow: hidden;
    height: 100%;
  }
  canvas {
    display: block;
    background: linear-gradient(to bottom, #0d0d0d, #1a1a1a);
  }
  #scoreBoard {
    position: absolute;
    top: 10px;
    width: 100%;
    text-align: center;
    font-family: Arial, sans-serif;
    font-size: 1.5rem;
    font-weight: bold;
    color: gold;
    text-shadow: 0 0 8px rgba(255,215,0,0.5);
  }
</style>
</head>
<body>
<div id="scoreBoard">Score: 0</div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
ctx.imageSmoothingEnabled = false;

function resizeCanvas() {
  canvas.width = window.innerWidth * 2;
  canvas.height = window.innerHeight * 2;
  ctx.setTransform(1, 0, 0, 1, 0, 0); 
  ctx.scale(2, 2);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Game settings
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = Math.floor(window.innerWidth / COLS);

let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
let score = 0;
let curPiece;

// Tetromino shapes
const pieces = [
  [[1,1,1,1]], // I
  [[1,1],[1,1]], // O
  [[0,1,0],[1,1,1]], // T
  [[1,0,0],[1,1,1]], // J
  [[0,0,1],[1,1,1]], // L
  [[1,1,0],[0,1,1]], // S
  [[0,1,1],[1,1,0]]  // Z
];

function randomPiece() {
  const shape = pieces[Math.floor(Math.random() * pieces.length)];
  return {
    shape,
    x: Math.floor(COLS / 2) - Math.ceil(shape[0].length / 2),
    y: 0
  };
}

function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Draw board
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) {
        drawBlock(c, r);
      }
    }
  }
  // Draw piece
  for (let r = 0; r < curPiece.shape.length; r++) {
    for (let c = 0; c < curPiece.shape[r].length; c++) {
      if (curPiece.shape[r][c]) {
        drawBlock(curPiece.x + c, curPiece.y + r);
      }
    }
  }
}

function drawBlock(x, y) {
  const px = x * BLOCK_SIZE;
  const py = y * BLOCK_SIZE;
  const grd = ctx.createLinearGradient(px, py, px+BLOCK_SIZE, py+BLOCK_SIZE);
  grd.addColorStop(0, "#FFD700");
  grd.addColorStop(1, "#B8860B");
  ctx.fillStyle = grd;
  ctx.fillRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
  ctx.strokeStyle = "#333";
  ctx.strokeRect(px, py, BLOCK_SIZE, BLOCK_SIZE);
}

function collide(shape, offsetX, offsetY) {
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      if (shape[r][c] && 
         (board[r + offsetY] && board[r + offsetY][c + offsetX]) !== 0) {
        return true;
      }
    }
  }
  return false;
}

function mergePiece() {
  for (let r = 0; r < curPiece.shape.length; r++) {
    for (let c = 0; c < curPiece.shape[r].length; c++) {
      if (curPiece.shape[r][c]) {
        board[curPiece.y + r][curPiece.x + c] = 1;
      }
    }
  }
}

function rotate(shape) {
  return shape[0].map((_, i) => shape.map(row => row[i])).reverse();
}

function clearLines() {
  let lines = 0;
  board = board.filter(row => {
    if (row.every(cell => cell !== 0)) {
      lines++;
      return false;
    }
    return true;
  });
  while (board.length < ROWS) {
    board.unshift(Array(COLS).fill(0));
  }
  if (lines) {
    score += lines * 100;
    document.getElementById("scoreBoard").innerText = `Score: ${score}`;
  }
}

let dropCounter = 0;
let dropInterval = 500;
let lastTime = 0;

function update(time = 0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) {
    curPiece.y++;
    if (collide(curPiece.shape, curPiece.x, curPiece.y)) {
      curPiece.y--;
      mergePiece();
      clearLines();
      curPiece = randomPiece();
      if (collide(curPiece.shape, curPiece.x, curPiece.y)) {
        board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        score = 0;
        document.getElementById("scoreBoard").innerText = `Score: ${score}`;
      }
    }
    dropCounter = 0;
  }
  drawBoard();
  requestAnimationFrame(update);
}

document.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") {
    if (!collide(curPiece.shape, curPiece.x - 1, curPiece.y)) curPiece.x--;
  } else if (e.key === "ArrowRight") {
    if (!collide(curPiece.shape, curPiece.x + 1, curPiece.y)) curPiece.x++;
  } else if (e.key === "ArrowDown") {
    curPiece.y++;
  } else if (e.key === "ArrowUp") {
    const rotated = rotate(curPiece.shape);
    if (!collide(rotated, curPiece.x, curPiece.y)) curPiece.shape = rotated;
  }
});

curPiece = randomPiece();
update();
</script>
</body>
</html>
