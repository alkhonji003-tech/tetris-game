<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Tetris ‚Äì Smooth & Colourful</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256'%3E%3Crect width='256' height='256' rx='56' fill='%23000'/%3E%3Cpath d='M36 36h80v80H36zM140 36h80v52h-80zM140 104h52v52h-52zM36 140h52v80H36zM100 140h52v52h-52zM168 168h52v52h-52z' fill='%23fff'/%3E%3C/svg%3E">
<style>
  :root{ --bg:#070b0f; --grid:#0f1720; --text:#e6f0ff; --accent:#5eead4; --btn:#0e1621; --btn2:#172234; --shadow:rgba(0,0,0,.45); }
  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
  html,body{height:100%; margin:0;}
  body{font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:radial-gradient(1200px 800px at 20% -20%, #0b1622, transparent 60%), linear-gradient(180deg,#05080c,#0a0f14); color:var(--text); display:flex; align-items:center; justify-content:center; padding:12px;}
  .wrap{width:100%; max-width:860px; display:grid; grid-template-columns:1fr; gap:14px;}
  header{display:flex; align-items:center; justify-content:space-between; gap:12px}
  h1{font-size:22px; margin:0; letter-spacing:.5px}
  .stats{display:flex; gap:10px; font-weight:700; flex-wrap:wrap}
  .stat{background:linear-gradient(180deg,var(--btn2),var(--btn)); padding:8px 12px; border-radius:12px; box-shadow:0 8px 20px var(--shadow);}

  .board{position:relative; background:linear-gradient(180deg,#0a0f14,#0a0f17); border-radius:16px; padding:10px; box-shadow:0 12px 28px var(--shadow);}
  .canvas-wrap{position:relative; border-radius:12px; overflow:hidden}
  canvas{display:block; width:100%; height:auto; background:conic-gradient(from 180deg at 50% 30%,#0d1318,#0b0f12 40%,#0d141a);} 
  .grid{position:absolute; inset:0; pointer-events:none; opacity:.35}

  .controls{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px; position:sticky; bottom:0;}
  button{appearance:none; border:none; border-radius:16px; padding:14px 10px; background:linear-gradient(180deg,var(--btn2),var(--btn)); color:var(--text); font-weight:800; box-shadow:0 10px 24px var(--shadow); font-size:16px}
  button:active{transform:translateY(1px)}

  .pill{padding:8px 10px; border-radius:999px; background:linear-gradient(180deg,#1b2638,#121a28); font-size:12px; display:inline-flex; align-items:center; gap:6px}
  .overlay{position:absolute; inset:10px; display:flex; align-items:center; justify-content:center; border-radius:12px; background:rgba(0,0,0,.45); backdrop-filter: blur(6px);} 
  .card{background:rgba(12,16,22,.8); padding:18px; border-radius:14px; text-align:center; box-shadow:0 10px 30px var(--shadow)}
  .title{font-size:22px; font-weight:900; margin-bottom:8px}
  .subtitle{opacity:.92; font-size:14px; margin:8px 0 14px}
  .small{font-size:12px; opacity:.78}
  .hidden{display:none}

  .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .mini{display:grid; grid-template-columns:repeat(6, 1fr); grid-auto-rows:10px; gap:2px; background:#0c131a; padding:8px; border-radius:10px}
  @media (min-width: 760px){ .wrap{grid-template-columns: 3fr 2fr; align-items:start} .controls{grid-column:1 / -1} }
</style>
</head>
<body>
<div class="wrap">
  <div>
    <header>
      <h1>üéÆ Tetris ‚Äì Smooth & Colourful</h1>
      <div class="stats">
        <div class="stat">Score: <span id="score">0</span></div>
        <div class="stat">Level: <span id="level">1</span></div>
        <div class="stat">Lines: <span id="lines">0</span></div>
      </div>
    </header>

    <div class="board">
      <div class="canvas-wrap">
        <canvas id="game" width="320" height="640" aria-label="Tetris board" role="img"></canvas>
        <canvas id="gridOverlay" class="grid" width="320" height="640" aria-hidden="true"></canvas>
      </div>
      <div class="overlay" id="overlay">
        <div class="card">
          <div class="title" id="stateTitle">Tap to Start</div>
          <div class="subtitle">Smooth 60fps falling, colourful gradients, crisp Retina scaling. Swipe ‚Üê/‚Üí to move, tap to rotate, swipe ‚Üì to soft drop, ‚§ì for hard drop.</div>
          <div class="pill">Tip: Add to Home Screen for full‚Äëscreen</div>
        </div>
      </div>
    </div>

    <div class="controls" aria-label="Controls">
      <button id="left" aria-label="Left">‚óÄÔ∏é</button>
      <button id="rotate" aria-label="Rotate">‚ü≥</button>
      <button id="right" aria-label="Right">‚ñ∂Ô∏é</button>
      <button id="drop" aria-label="Hard drop">‚§ì</button>
      <button id="soft" aria-label="Soft drop">‚¨áÔ∏é</button>
      <button id="pause" aria-label="Pause/Resume">‚ñå‚ñå</button>
      <button id="restart" aria-label="Restart">‚Üª</button>
      <button id="mute" aria-label="Mute/Unmute">üîä</button>
    </div>

    <div class="small" style="margin-top:6px">Works offline when added to Home Screen (saved in Safari cache). No data collection.</div>
  </div>
  <div class="hud">
    <div>
      <div class="pill" style="margin-bottom:8px">Next</div>
      <div id="next" class="mini" style="width:120px; grid-auto-rows:16px"></div>
    </div>
    <div>
      <div class="pill" style="margin-bottom:8px">Hold</div>
      <div id="hold" class="mini" style="width:120px; grid-auto-rows:16px"></div>
    </div>
  </div>
</div>

<script>
(function(){
  // ===== Canvas & Retina Scaling =====
  const canvas = document.getElementById('game');
  const gridCanvas = document.getElementById('gridOverlay');
  const ctx = canvas.getContext('2d');
  const gtx = gridCanvas.getContext('2d');
  const DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 3));
  function fitCanvas(c){ const w = c.width, h = c.height; c.style.width = '100%'; const cssW = c.clientWidth || c.parentElement.clientWidth; const ratio = cssW / w; c.height = Math.round(h * ratio * DPR); c.width = Math.round(w * ratio * DPR); c.style.height = Math.round(h * ratio) + 'px'; c.dataset.cell = (c.width/10).toFixed(2); return {w:c.width, h:c.height, cell:c.width/10}; }
  function resize(){ fitCanvas(canvas); fitCanvas(gridCanvas); drawGrid(); }
  window.addEventListener('resize', resize, {passive:true});

  // ===== Game Constants =====
  const W=10, H=20;
  const SHAPES = {
    I:[[1,1,1,1]],
    J:[[1,0,0],[1,1,1]],
    L:[[0,0,1],[1,1,1]],
    O:[[1,1],[1,1]],
    S:[[0,1,1],[1,1,0]],
    T:[[0,1,0],[1,1,1]],
    Z:[[1,1,0],[0,1,1]]
  };
  const PALETTE = {
    I:['#5ee7ff','#2196f3'],
    J:['#8ec5ff','#3b82f6'],
    L:['#ffd48a','#f59e0b'],
    O:['#fff59d','#facc15'],
    S:['#9df3c4','#22c55e'],
    T:['#d1b3ff','#8b5cf6'],
    Z:['#ffb4b4','#ef4444'],
    X:['#93a3b8','#1f2937'] // ghost
  };

  // ===== State =====
  let grid = Array.from({length:H},()=>Array(W).fill(null));
  let bag = [];
  function nextFromBag(){ if(bag.length===0){ bag = Object.keys(SHAPES); for(let i=bag.length-1;i>0;i--){ const j=(Math.random()* (i+1))|0; [bag[i],bag[j]]=[bag[j],bag[i]]; } } return bag.pop(); }
  function spawnPiece(type){ const shape = SHAPES[type].map(r=>r.slice()); return {type, shape, x: Math.floor(W/2) - Math.ceil(shape[0].length/2), y: -1, yFloat:-1, rot:0}; }
  let cur = spawnPiece(nextFromBag());
  let hold = null, canHold=true;
  let queue = [nextFromBag(), nextFromBag(), nextFromBag()];

  let score=0, level=1, lines=0;
  let running=false, gameOver=false, muted=false;

  // Smooth gravity: cells per second baseline, increases with level
  function gravityPerSecond(){ return 1.0 + (level-1)*0.15; }
  let softDropBoost = 1.0; // when holding soft drop

  // ===== Collisions =====
  function collide(nx, ny, shape){ const s=shape||cur.shape; for(let y=0;y<s.length;y++){ for(let x=0;x<s[y].length;x++){ if(!s[y][x]) continue; const gx=(nx??cur.x)+x; const gy=(ny??cur.y)+y; if(gx<0||gx>=W||gy>=H|| (gy>=0 && grid[gy][gx])) return true; } } return false; }

  // Wall kicks (simple): try offsets left/right
  function rotated(mat){ const N=mat.length, M=mat[0].length; const res=Array.from({length:M},(_,y)=>Array.from({length:N},(_,x)=>mat[N-1-x][y])); return res; }
  function tryRotate(){ const r=rotated(cur.shape); const kicks=[0,-1,1,-2,2]; for(const k of kicks){ if(!collide(cur.x+k, cur.y, r)){ cur.shape=r; cur.x+=k; return true; } } return false; }

  function lock(){ for(let y=0;y<cur.shape.length;y++){ for(let x=0;x<cur.shape[y].length;x++){ if(cur.shape[y][x]){ const gy=cur.y+y, gx=cur.x+x; if(gy<0){ endGame(); return; } grid[gy][gx]=cur.type; } } } lineClear(); canHold=true; spawnNew(); }
  function spawnNew(){ cur = spawnPiece(queue.shift()); queue.push(nextFromBag()); }

  function lineClear(){ let removed=0; for(let y=H-1;y>=0;y--){ if(grid[y].every(Boolean)){ grid.splice(y,1); grid.unshift(Array(W).fill(null)); removed++; y++; } }
    if(removed){ lines+=removed; const points=[0,40,100,300,1200][removed]*level; score+=points; level = 1 + Math.floor(lines/10); updateHud(); }
  }

  function ghostY(){ let y=cur.y; while(!collide(cur.x, y+1)) y++; return y; }

  // ===== Rendering =====
  function drawGrid(){ const cell = canvas.width/10; gtx.clearRect(0,0,gridCanvas.width,gridCanvas.height); gtx.globalAlpha=.45; gtx.fillStyle='#0f1720'; for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ gtx.fillRect(x*cell+1, y*cell+1, cell-2, cell-2); } } gtx.globalAlpha=1; }

  function cellGradient(x, y, type){ const cell = canvas.width/10; const px = x*cell, py=y*cell; const g=ctx.createLinearGradient(px,py,px,py+cell); const [a,b]=PALETTE[type]; g.addColorStop(0,a); g.addColorStop(1,b); return g; }
  function glossyHighlight(x,y){ const cell=canvas.width/10; const px=x*cell, py=y*cell; const r=ctx.createLinearGradient(px,py,px,py+cell*0.6); r.addColorStop(0,'rgba(255,255,255,.28)'); r.addColorStop(1,'rgba(255,255,255,0)'); return r; }
  function drawCell(x,y,type,alpha=1){ const cell=canvas.width/10; const px=x*cell, py=y*cell; ctx.globalAlpha=alpha; ctx.fillStyle=cellGradient(x,y,type); ctx.fillRect(px+1, py+1, cell-2, cell-2); // inner shadow
    ctx.globalAlpha=alpha*0.65; ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(px+1, py+cell-4, cell-2, 3); // gloss
    ctx.globalAlpha=alpha; ctx.fillStyle=glossyHighlight(x,y); ctx.fillRect(px+2, py+2, cell-4, cell*0.45); ctx.globalAlpha=1; }

  function drawBoard(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(let y=0;y<H;y++){ for(let x=0;x<W;x++){ if(grid[y][x]) drawCell(x,y,grid[y][x]); } }
    // ghost
    const gy = ghostY(); for(let y=0;y<cur.shape.length;y++){ for(let x=0;x<cur.shape[y].length;x++){ if(cur.shape[y][x]){ const yy=gy+y, xx=cur.x+x; if(yy>=0) drawCell(xx,yy,'X',.22); } } }
    // current piece (smooth y)
    const cell = canvas.width/10; const yOffset = (cur.yFloat - Math.floor(cur.yFloat)) * cell; for(let y=0;y<cur.shape.length;y++){ for(let x=0;x<cur.shape[y].length;x++){ if(cur.shape[y][x]){ const drawY = Math.floor(cur.yFloat)+y; if(drawY>=0){ ctx.save(); ctx.translate(0, yOffset); drawCell(cur.x+x, drawY, cur.type); ctx.restore(); } } } }
  }

  // ===== HUD (Next & Hold) =====
  const nextEl=document.getElementById('next');
  const holdEl=document.getElementById('hold');
  function renderMini(container, type){ container.innerHTML=''; const shape=SHAPES[type]; const w=shape[0].length, h=shape.length; const gridW=6, gridH=4; const offX=Math.floor((gridW - w)/2), offY=Math.floor((gridH - h)/2); const cells=[]; for(let y=0;y<gridH;y++){ for(let x=0;x<gridW;x++){ const d=document.createElement('div'); d.style.background = (shape[y-offY]?.[x-offX])? `linear-gradient(180deg, ${PALETTE[type][0]}, ${PALETTE[type][1]})` : '#0c131a'; d.style.borderRadius='3px'; container.appendChild(d); } }
  }
  function updateHud(){ document.getElementById('score').textContent=score; document.getElementById('level').textContent=level; document.getElementById('lines').textContent=lines; renderMini(nextEl, queue[0]); renderMini(holdEl, hold || 'O'); }

  // ===== Loop =====
  let last=performance.now();
  function tick(now){ if(!running) return; const dt=(now-last)/1000; last=now; const g = gravityPerSecond()*softDropBoost; cur.yFloat += g*dt; const nextY = Math.floor(cur.yFloat);
    if(nextY !== cur.y){ // Try to move down whole rows if passed
      let moved=false; while(cur.y < nextY){ if(!collide(cur.x, cur.y+1)){ cur.y++; moved=true; } else { cur.yFloat = cur.y; lock(); break; } } if(moved) drawBoard(); }
    drawBoard(); requestAnimationFrame(tick); }

  // ===== Controls =====
  function start(){ if(running) return; if(gameOver) reset(); running=true; document.getElementById('overlay').classList.add('hidden'); last=performance.now(); requestAnimationFrame(tick); }
  function pause(){ running=false; document.getElementById('overlay').classList.remove('hidden'); document.getElementById('stateTitle').textContent='Paused'; }
  function reset(){ grid = Array.from({length:H},()=>Array(W).fill(null)); score=0; lines=0; level=1; softDropBoost=1; gameOver=false; bag=[]; cur=spawnPiece(nextFromBag()); queue=[nextFromBag(), nextFromBag(), nextFromBag()]; updateHud(); drawBoard(); }
  function endGame(){ running=false; gameOver=true; document.getElementById('overlay').classList.remove('hidden'); document.getElementById('stateTitle').textContent='Game Over ‚Äì tap to restart'; }

  // Buttons
  const B=id=>document.getElementById(id);
  B('left').addEventListener('touchstart', e=>{ e.preventDefault(); if(!collide(cur.x-1, cur.y)) cur.x--; drawBoard(); });
  B('right').addEventListener('touchstart', e=>{ e.preventDefault(); if(!collide(cur.x+1, cur.y)) cur.x++; drawBoard(); });
  B('rotate').addEventListener('touchstart', e=>{ e.preventDefault(); tryRotate(); drawBoard(); });
  B('drop').addEventListener('touchstart', e=>{ e.preventDefault(); // hard drop
    while(!collide(cur.x, cur.y+1)) cur.y++; cur.yFloat=cur.y; lock(); drawBoard(); });
  B('soft').addEventListener('touchstart', e=>{ e.preventDefault(); softDropBoost=18; });
  B('soft').addEventListener('touchend', e=>{ e.preventDefault(); softDropBoost=1; });
  B('pause').addEventListener('touchstart', e=>{ e.preventDefault(); running?pause():start(); });
  B('restart').addEventListener('touchstart', e=>{ e.preventDefault(); reset(); });
  B('mute').addEventListener('touchstart', e=>{ e.preventDefault(); muted=!muted; B('mute').textContent= muted ? 'üîá' : 'üîä'; });

  // Hold (double-tap canvas)
  const overlay=document.getElementById('overlay');
  let lastTap=0;

  // Swipe & Tap on canvas
  let startX=0, startY=0, moved=false;
  canvas.addEventListener('touchstart', e=>{ const t=e.touches[0]; startX=t.clientX; startY=t.clientY; moved=false; softDropBoost=1; });
  canvas.addEventListener('touchmove', e=>{
    const t=e.touches[0]; const dx=t.clientX-startX; const dy=t.clientY-startY; if(Math.abs(dx)>20 || Math.abs(dy)>20) moved=true;
    if(Math.abs(dx)>26 && Math.abs(dx)>Math.abs(dy)) { if(dx>0 && !collide(cur.x+1, cur.y)) cur.x++; if(dx<0 && !collide(cur.x-1, cur.y)) cur.x--; startX=t.clientX; drawBoard(); }
    if(dy>28 && Math.abs(dy)>Math.abs(dx)) { softDropBoost=18; }
  }, {passive:true});
  canvas.addEventListener('touchend', e=>{ if(!moved){ const now=performance.now(); if(now-lastTap<260){ // double tap => hold
        if(canHold){ const tmp=hold; hold=cur.type; if(tmp){ cur = spawnPiece(tmp); } else { cur = spawnPiece(queue.shift()); queue.push(nextFromBag()); } canHold=false; cur.x=Math.floor(W/2)-Math.ceil(cur.shape[0].length/2); cur.y=-1; cur.yFloat=-1; }
      } else { tryRotate(); } lastTap=now; } softDropBoost=1; drawBoard(); });

  // Keyboard for desktop
  window.addEventListener('keydown', e=>{
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space','KeyP','KeyC'].includes(e.code)) e.preventDefault();
    if(e.code==='ArrowLeft' && !collide(cur.x-1,cur.y)) cur.x--;
    if(e.code==='ArrowRight' && !collide(cur.x+1,cur.y)) cur.x++;
    if(e.code==='ArrowUp') tryRotate();
    if(e.code==='ArrowDown') softDropBoost=18;
    if(e.code==='Space'){ while(!collide(cur.x,cur.y+1)) cur.y++; cur.yFloat=cur.y; lock(); }
    if(e.code==='KeyP') running?pause():start();
    if(e.code==='KeyC' && canHold){ const tmp=hold; hold=cur.type; if(tmp){ cur = spawnPiece(tmp); } else { cur = spawnPiece(queue.shift()); queue.push(nextFromBag()); } canHold=false; cur.x=Math.floor(W/2)-Math.ceil(cur.shape[0].length/2); cur.y=-1; cur.yFloat=-1; }
    drawBoard();
  });
  window.addEventListener('keyup', e=>{ if(e.code==='ArrowDown') softDropBoost=1; });

  // Start/pause overlay
  overlay.addEventListener('click', ()=> running?pause():start());

  // Initial
  resize();
  updateHud();
  drawBoard();
})();
</script>
</body>
</html>
